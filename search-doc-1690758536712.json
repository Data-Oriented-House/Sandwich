[{"title":"Sandwich","type":0,"sectionRef":"#","url":"/Sandwich/api/Sandwich","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Sandwich","url":"/Sandwich/api/Sandwich#functions","content":" "},{"title":"schedule​","type":1,"pageTitle":"Sandwich","url":"/Sandwich/api/Sandwich#schedule","content":"&lt;/&gt; Sandwich.schedule(parameters: { before: ( Job, ...any ) → ()?, after: ( Job, ...any ) → ()?, }?) → Schedule Creates a new schedule that can be used to create jobs. Optionally takes in a before and after callback that will be called before and after each job is executed.  "},{"title":"interval​","type":1,"pageTitle":"Sandwich","url":"/Sandwich/api/Sandwich#interval","content":"&lt;/&gt; Sandwich.interval( seconds: number, callback: (T...) → boolean?, ...: T... ) → thread Creates a new thread that will execute a callback every given number of seconds. If the callback returns a non-nil value, the thread will stop executing. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/Sandwich/docs/intro","content":"","keywords":""},{"title":"Why Would I Need Sandwich?​","type":1,"pageTitle":"Introduction","url":"/Sandwich/docs/intro#why-would-i-need-sandwich","content":"In Luau and Roblox there just aren't good ways to guarantee jobs run in a certain order. Roblox offers RunService, but uses an unfriendly priority system for RenderStepped that isn't even available for Heartbeat or other events, making ordering impossible on the Server. Luau just doesn't have any way to automatically order jobs at all. "},{"title":"What Does Sandwich Do?​","type":1,"pageTitle":"Introduction","url":"/Sandwich/docs/intro#what-does-sandwich-do","content":"Sandwich simply lets you order jobs by specifying dependencies. Almost identical in concept to requiring modules to execute code. It uses topological sorting to order jobs, and then runs them in order. It also offers a way to execute code on intervals. That's it. Nothing crazy. "},{"title":"How Do I Use Sandwich?​","type":1,"pageTitle":"Introduction","url":"/Sandwich/docs/intro#how-do-i-use-sandwich","content":"Very simple! You create Schedules and then add Jobs to them. local newSchedule = Sandwhich.schedule() -- Runs concurrently with secondJob local firstJob = newSchedule.job(function(text: string | number) print(&quot;First &quot; .. text) end) -- Runs concurrently with firstJob local secondJob = newSchedule.job(function(text: string | number) print(&quot;Second &quot; .. text) end) -- Always runs after firstJob local thirdJob = newSchedule.job(function(text: string | number) print(&quot;Third &quot; .. text) end, firstJob)  Then you can then start the schedule and all of the jobs will execute in topological order! Topological order in this case means dependencies will always be executed before the jobs that depend on them. newSchedule.start(&quot;is running&quot;) -- First is running -- Second is running -- Third is running  Now every time you want to run a schedule, you call the start method. This makes it incredibly easy to integrate with pre-existing schedulers like Roblox's RunService, or work with event-driven systems like user-input. RunService.Heartbeat:Connect(newSchedule.start) -- Second 0.016 -- First 0.016 -- Third 0.016 local renderSchedule = Sandwhich.schedule() Runservice.RenderStepped:Connect(renderSchedule.start)  "},{"title":"Schedule","type":0,"sectionRef":"#","url":"/Sandwich/api/Schedule","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#types","content":" "},{"title":"Schedule​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#Schedule","content":"&lt;/&gt; interface Schedule { job: ( jobTask: (...: any) → (), ...: Job ) → Job start: (...: any) → () before: ( job: Job, ...: any ) → ()? after: ( job: Job, ...: any ) → ()? graph: {[Job]: {Job}} jobs: {Job} }  "},{"title":"Functions​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#functions","content":" "},{"title":"job​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#job","content":"&lt;/&gt; Schedule.job( jobTask: (...any) → (), ...: Job ) → () "},{"title":"Types","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule##","content":""},{"title":"​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#Job","content":"type Job = (...any) → ()  Creates a new job that can be executed later by calling Schedule.start. Takes in other jobs as dependencies, which must be executed before this job is executed. local schedule = Sandwich.schedule() local a = schedule.job(function(...) print(&quot;a&quot;, ...) end) local b = schedule.job(function(...) print(&quot;b&quot;, ...) end) local c = schedule.job(function(...) print(&quot;c&quot;, ...) end, a) local d = schedule.job(function(...) print(&quot;d&quot;, ...) end, a, b) local e = schedule.job(function(...) print(&quot;e&quot;, ...) end, c, d) local f = schedule.job(function(...) print(&quot;f&quot;, ...) end, a, e, b, c)   "},{"title":"start​","type":1,"pageTitle":"Schedule","url":"/Sandwich/api/Schedule#start","content":"&lt;/&gt; Schedule.start(...: any) → () Executes a schedule's tasks in topological order. schedule.start(&quot;Hello, world!&quot;) -- b\tHello, world! -- a\tHello, world! -- d\tHello, world! -- c\tHello, world! -- e\tHello, world! -- f\tHello, world!  "},{"title":"Examples","type":0,"sectionRef":"#","url":"/Sandwich/docs/examples","content":"","keywords":""},{"title":"Basic Example​","type":1,"pageTitle":"Examples","url":"/Sandwich/docs/examples#basic-example","content":"local schedule = sandwich.schedule() function schedule.before(job: Job, ...) print(&quot;Before&quot;, job, ...) end function schedule.after(job: Job, ...) print(&quot;After&quot;, job, ...) end local a = schedule.job(function(...) print(&quot;a&quot;, ...) end) local b = schedule.job(function(...) print(&quot;b&quot;, ...) end) local c = schedule.job(function(...) print(&quot;c&quot;, ...) end, a, b) local d = schedule.job(function(...) print(&quot;d&quot;, ...) end, b, c) local e = schedule.job(function(...) print(&quot;e&quot;, ...) end, c) local f = schedule.job(function(...) print(&quot;f&quot;, ...) end, a, c, e) schedule.start('1', '2')  "},{"title":"ECS Example​","type":1,"pageTitle":"Examples","url":"/Sandwich/docs/examples#ecs-example","content":"Let's use a fake ECS for example, since these are always fun to schedule because of their use of Systems. local ECS = require(Some.Funny.ECS) local schedule = sandwich.schedule { before = function(job: Job, deltaTime: number) print(&quot;Starting&quot;, job, deltaTime) end, } local function updateAccelerations(deltaTime: number, entities) for entity in entities do entity.acceleration = (entity.target - entity.position) * deltaTime end end local function updateVelocities(deltaTime: number, entities) for entity in entities do entity.velocity += entity.acceleration * deltaTime end end local function updatePositions(deltaTime: number, entities) for entity in entities do entity.position += entity.velocity * deltaTime end end local accelerationSystem = schedule.job(function(deltaTime: number) print(&quot;Updating Acceleration&quot;, deltaTime) updateAccelerations(deltaTime, ECS.query(&quot;target&quot;, &quot;position&quot;, &quot;acceleration&quot;)) end) local velocitySystem = schedule.job(function(deltaTime: number) print(&quot;Updating Velocity&quot;, deltaTime) updateVelocities(deltaTime, ECS.query(&quot;velocity&quot;, &quot;acceleration&quot;)) end, accelerationSystem) local positionSystem = schedule.job(function(deltaTime: number) print(&quot;Updating Position&quot;, deltaTime) updatePositions(deltaTime, ECS.query(&quot;position&quot;, &quot;velocity&quot;)) end, velocitySystem) RunService.Heartbeat:Connect(schedule.start)  "}]